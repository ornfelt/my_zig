test optimize
set opt_level=speed
target x86_64

; An eclass that is transitively referenced by a side-effecting instruction in a
; block must not contain any alternatives that use values which are not available
; in that block. If we violate this rule, then we only get correct results if
; elaboration happens to not choose the bad alternatives, which means we're
; relying on the cost function, and there's no reason to believe that's reliable
; for this purpose.
; 
; Unfortunately, we can't currently write test assertions about which alternatives
; are generated by simplification in the egraph pass. We can only observe which
; choice was selected by the cost function. So instead these tests try to hit
; assertions in the egraph pass if the above rule is broken.
; 
; These tests are carefully constructed to hit specific code paths in the egraph
; pass without getting key parts transformed away by other optimizations first:
; 
; - There are no loops, to avoid having LICM move the code we care about.
; 
; - There are two blocks which contain pure instructions that are identical after
;   simplification.
; 
; - Neither of these blocks dominates the other, so GVN will only combine them if
;   we allow it to consider instructions in different scopes.
; 
; - References to these blocks are constructed to create a specific domtree so the
;   egraph pass will traverse them in a specific order.
; 
; - The block which the egraph pass examines first uses a value that is only
;   available in that block: a block-param or the result of an effectful
;   instruction.
; 
; By doing all that, we create an opportunity where the first block could produce
; an eclass which references the value that's only available in that block, and
; GVN could reuse that eclass for the equivalent instruction in the second block.
; If the egraph pass does both of those things then it violates the rule above.
;
; For more discussion, see:
; https://github.com/bytecodealliance/wasmtime/pull/7891

function %bad_param_reuse(i32) -> i8 {
block0(v0: i32): 
    v1 = iconst.i32 0
    brif v0, block1, block2(v0)

block1:
; To prevent the remove-constant-phi pass from removing the block-param, there are
; multiple references to block2 using different values for the block-param. This
; reference is dynamically unreachable but Cranelift doesn't know that.
    brif v0, block3, block2(v1)

block2(v2: i32):
    v3 = isub v2, v2
    ; v3 simplifies to `iconst 0`, which is equivalent to v1
    v4 = icmp eq v0, v3
    return v4

block3:
    ; If this icmp replaces v1 with v3, elaboration would clone the isub into this
    ; block, introducing a reference to v2, which is not in scope here.
    v5 = icmp eq v0, v1
    return v5
}

; check: block2(v2: i32):
; check:     v8 = iconst.i32 0
; check:     v4 = icmp.i32 eq v0, v8  ; v8 = 0
; check:     return v4
; check: block3:
; check:     v6 = iconst.i32 0
; check:     v7 = icmp.i32 eq v0, v6  ; v6 = 0
; check:     return v7

function %bad_effect_reuse(i64) -> i8 {
block0(v0: i64):
    brif v0, block1, block2

block1:
    v1 = load.i64 heap v0
    v2 = isub v1, v1
    ; v2 simplifies to `iconst 0`, which is equivalent to v4
    v3 = icmp eq v0, v2
    return v3

block2:
    v4 = iconst.i64 0
    ; If this icmp replaces v4 with v2, elaboration would clone the isub into this
    ; block, introducing a reference to v1, which is not in scope here.
    v5 = icmp eq v0, v4
    return v5
}

; check: block1:
; check:     v1 = load.i64 heap v0
; check:     v7 = iconst.i64 0
; check:     v8 = icmp.i64 eq v0, v7  ; v7 = 0
; check:     return v8
; check: block2:
; check:     v6 = iconst.i64 0
; check:     v3 = icmp.i64 eq v0, v6  ; v6 = 0
; check:     return v3
